#
# Bookmarks CLI commands so they don't get lost in history.
# Author: Brad Frank
# Date: August 2021
# Tested: zsh 5.8 (x86_64-apple-darwin20.1.0)
# Requires: fzf, bat; Recommended: gh
#
# To get started:
#   1. Source this file (add `source /path/to/cmarks` to your `.zshrc`)
#
# To use sync:
#   1. Create a GitHub Gist (private or public) and note the hash ID (in the url)
#   2. Add the Gist hash ID to the config file
#
# Help:
#   Find the history index number for a recent command:
#   `fc -l`
#
#   Add a single command to cmarks (also works for delete/retrieve/print):
#   `cmarks -a <num>`
#
#   Add the previous command to cmarks:
#   `cmarks -a -1`
#
#   Add a range of commands to cmarks (also works for delete/retrieve/print):
#   `cmarks -a <num1>,<num2>`
#
# Notes:
#   * Bookmarked commands have separate index numbers than zsh history.
#   * Index numbers are re-assigned when bookmarks are removed.
#   * Sync is rudimentary, use with caution.
#

export CMARKS_CONFIG=$HOME/.config/cmarks

if [[ ! -s "$CMARKS_CONFIG" ]]; then
  echo "CMARKS_FILE=$HOME/.cmarks" >> "$CMARKS_CONFIG"
  echo "CMARKS_GIST=" >> "$CMARKS_CONFIG"
fi

alias cma='cmarks -a'
alias cmd='cmarks -d'
alias cmf='cmarks -f'
alias cml='cmarks -l'
alias cmp='cmarks -p'
alias cmr='cmarks -r'
alias cms='cmarks -s'
alias fcl='fc -l'

function cmarks() {
  [[ ! -x $(which fzf) || ! -x $(which bat) ]] && { echo "Missing dependencies."; return 1; }
  source "$CMARKS_CONFIG"; [[ -f "$CMARKS_FILE" ]] || touch "$CMARKS_FILE"

  _cm_usage() {
    echo "Usage: cmarks [OPTION]"
    echo "-a <num1>[,<num2>]    Add commands from history"
    echo "-d <num1>[,<num2>]    Delete commands from bookmarks"
    echo "-f                    Use fzf to find commands in bookmarks and append to history"
    echo "-l                    List all commands in bookmarks"
    echo "-p <num1>[,<num2>]    Print commands to stdout from bookmarks"
    echo "-r <num1>[,<num2>]    Retrieve commands from bookmarks and append to history"
    echo "-s push|pull          Sync bookmarks with GitHub gist"
  }

  _cm_gist_sync() {
    gh auth status &> /dev/null || { echo "Not authenticated to GitHub." >&2; return 1; }
    [[ -z $CMARKS_GIST ]] && { echo "No Gist ID set." >&2; return 1; }
    case $OPTARG in push) _cm_gist_push ;; pull) _cm_gist_pull ;; *) { _cm_usage >&2; return 1; } ;; esac
    return $?
  }
  _cm_gist_pull() { sort -u =(gh gist view "$CMARKS_GIST"; cat "$CMARKS_FILE") > "$CMARKS_FILE"; }
  _cm_gist_push() { VISUAL='tee' gh gist edit "$CMARKS_GIST" < "$CMARKS_FILE" > /dev/null; }
  _cm_arg() { cut -d, -f$1 <<< $OPTARG; }
  _cm_fzfind() { fzf --ansi -i --exit-0 --height=50% --no-multi --inline-info --border rounded < "$1"; }
  _cm_println() { sed "${OPTARG}!d" "$CMARKS_FILE" | sed -E "s/${date_regex}\s+//"; }
  _cm_compact() { cat =(awk NF "$CMARKS_FILE") > "$CMARKS_FILE"; }

  local date_regex="^[0-9]{4}(-[0-9]+){2}\s(:?[0-9]+){2}" rc

  while getopts ':ha:d:flp:r:s:' flag; do
    case "$flag" in
      h)  _cm_usage; return 0 ;;
      a)  fc -lin "$(_cm_arg 1)" "$(_cm_arg 2)" >> "$CMARKS_FILE"; rc=$?; _cm_compact; return $rc ;;
      d)  sed -i "${OPTARG}d" "$CMARKS_FILE"; rc=$?; _cm_compact; return $rc ;;
      f)  fc -R =(_cm_fzfind "$CMARKS_FILE" | sed -E "s/${date_regex}\s+//"); return $? ;;
      l)  bat --number "$CMARKS_FILE"; return $? ;;
      p)  _cm_println; return $? ;;
      r)  fc -R =(_cm_println); return $? ;;
      s)  _cm_gist_sync; return $? ;;
      \?) echo "cmarks: invalid option -$OPTARG" >&2 ;;
      :)  echo "cmarks: option -$OPTARG requires an argument" >&2 ;;
    esac
  done

  echo; _cm_usage >&2; return 1
}

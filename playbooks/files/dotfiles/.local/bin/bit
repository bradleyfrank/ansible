#!/usr/bin/env bash

#
# Branches a Git repo as a worktree within tmux.
# Author: Brad Frank
# Date: May 2021, July 2022
# Tested: GNU bash, version 5.1.12(1)-release (x86_64-apple-darwin21.1.0)
# Requires: tmux, git, fzf, gh
#

usage() {
  if [[ "$1" =~ (branch|all) ]]; then
    echo "bit branch [-n <name>] [-p|-w]"
    echo "  -n  Name of the new branch"
    echo "  -p  Opens the branch in a tmux pane in the same window (default)"
    echo "  -w  Opens the branch in a new tmux window"
  fi

  if [[ "$1" =~ (pull|all) ]]; then
    echo "bit pull [-n <name>] [-p|-w]"
    echo "  -n  Name of branch to pull"
    echo "  -p  Opens the branch in a tmux pane in the same window (default)"
    echo "  -w  Opens the branch in a new tmux window"
  fi

  if [[ "$1" =~ (delete|all) ]]; then
    echo "bit delete"
  fi

  if [[ "$1" =~ (clone|all) ]]; then
    echo "bit clone [<url>]"
  fi
}

in_git_repo() {
  if ! git_toplevel_path="$(git rev-parse --show-toplevel 2> /dev/null)" 2> /dev/null; then
    echo "Must be in a Git repository" >&2
    return 1
  fi
}

fzf_bit() {
  if [[ -n $TMUX ]]; then
    fzf-tmux -p --select-1 --ansi -i --height=50% --reverse -0 --inline-info --border "$@"
  else
    fzf --select-1 --ansi -i --height=50% --reverse -0 --inline-info --border "$@"
  fi
}

bit_branch() {
  in_git_repo || exit 1
  repo_base_path="$(dirname "$git_toplevel_path")"
  cd "$git_toplevel_path" || exit 1
  [[ -z $new_branch_name ]] && new_branch_name="$(date +%Y-%b-%d-%H%M)-$(basename "$git_toplevel_path")"
  repo_branch_path="$repo_base_path/$new_branch_name"
  git worktree add "$repo_branch_path"
  open_in_tmux
}

bit_pull() {
  in_git_repo || exit 1
  repo_base_path="$(dirname "$git_toplevel_path")"
  git fetch origin --prune
  new_branch_name="$(
    git for-each-ref --format='%(refname:short)' refs/remotes \
      | cut --delimiter / --fields 2- \
      | grep --extended-regexp --invert-match '^(HEAD|main|master)$' \
      | grep "$new_branch_name" \
      | fzf_bit --no-multi --preview='git log --pretty=reference origin/{}'
  )"
  repo_branch_path="$repo_base_path/$new_branch_name"
  # TODO: Fix path!
  git worktree add "$repo_branch_path"
  cd "$repo_branch_path" || exit 1
  git branch --set-upstream-to origin/"$new_branch_name" "$new_branch_name"
  git pull
  git reset --hard origin/"$new_branch_name"
  open_in_tmux
}

bit_delete() {
  local worktree
  in_git_repo || exit 1
  while read -r worktree; do
    [[ -z $worktree ]] && { echo "No worktree(s) selected." >&2; exit 1; }
    [[ "$worktree" == "$git_toplevel_path" ]] && { echo "Cannot delete active worktree." >&2; exit 1; }
    git worktree remove --force "$worktree"
    git branch --delete --force "$(basename "$worktree")"
  done <<< "$(
    git worktree list --porcelain \
      | grep --extended-regexp '^worktree' \
      | awk '{print $2}' \
      | fzf_bit --multi --preview='git log {} --' --delimiter / --with-nth -1
  )"
}

bit_clone() {
  local gh_repo repo_url tmp_repo; repo_url="$1"

  if [[ -z $repo_url ]]; then
    org_name="$( { gh api user/orgs --jq '.[].login' && gh api user --jq '.login'; } | fzf_bit --no-multi)"
    #shellcheck disable=SC2016
    gh_repo="$(
      gh api graphql --paginate --field owner="$org_name" --raw-field query='
        query ($owner: String!, $endCursor: String) {
          repositoryOwner(login: $owner) {
            repositories(first: 30, after: $endCursor) {
              pageInfo { hasNextPage, endCursor }
              nodes { nameWithOwner }
            }
          }
        }' --jq '.data.repositoryOwner.repositories.nodes[].nameWithOwner' \
        | fzf_bit --no-multi --preview='git log --pretty=reference origin/{}'
    )"
    [[ -z $gh_repo ]] && { echo "No valid repository url provided." >&2; exit 1; }
    repo_url="git@github.com:${gh_repo}.git"
    repo_name="$(basename "$gh_repo")"
  elif git ls-remote --quiet "$1" 2> /dev/null; then
    repo_name="$(basename "${repo_url/.git/}")"
  else
    echo "No valid repository url provided." >&2
    exit 1
  fi

  repo_base_path="$projects_dir/$repo_name"
  mkdir --parents "$repo_base_path" || exit 1
  tmp_repo="$(mktemp --directory)"
  git clone "$repo_url" "$tmp_repo/$repo_name"
  cd "$tmp_repo/$repo_name" || exit 1
  repo_branch_path="$repo_base_path/$(git branch --show-current)"
  mv --no-target-directory "$tmp_repo/$repo_name" "$repo_branch_path"
  open_in_tmux
}

open_in_tmux() {
  if [[ -n $TMUX ]]; then
    case $open_in in
      window) tmux-utils open-project -d "$repo_branch_path" ;;
      pane)   tmux split-window -h -c "$repo_branch_path" ;;
    esac
  else
    cd "$repo_branch_path" || exit 1
  fi
}


main() {
  local OPTIND subcommand
  local projects_dir open_in git_toplevel_path org_name repo_name repo_base_path repo_branch_path

  projects_dir="$HOME/Development/Projects"
  open_in="window"

  while getopts "h" opt; do
    case "$opt" in
      h) usage "all"; exit 0 ;;
      *) echo "Invalid option: $OPTARG" >&2; usage "all"; exit 1 ;;
    esac
  done

  shift $((OPTIND-1)); subcommand="$1"; shift

  while getopts ':hn:pw' flag; do
    case "$flag" in
      h) usage "$subcommand"; exit 0 ;;
      n) new_branch_name="$OPTARG" ;;
      p) open_in="pane" ;;
      w) open_in="window" ;;
      :) echo "Must supply an argument to -$OPTARG." >&2; usage "$subcommand"; exit 1 ;;
     \?) echo "Invalid option: $OPTARG" >&2; usage "$subcommand"; exit 1 ;;
    esac
  done

  case "$subcommand" in
    create) echo "Use 'branch' instead." ;;
    branch) bit_branch     ;;
      pull) bit_pull       ;;
    delete) bit_delete     ;;
     clone) bit_clone "$1" ;;
  esac
}

main "$@"
